import subprocess
import asyncio
import json
import re
import logging
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
import tempfile
import os
import uuid

from ..models.vulnerability_models import (
    VulnerabilityTool, VulnerabilityInfo, VulnerabilityScanResult, VulnerabilitySeverity,
    VulnerabilityType, VulnerabilityScanJob
)
from .database import get_database

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Service for vulnerability scanning operations"""
    
    def __init__(self):
        self.tools_status = {}
    
    async def check_tool_installation(self, tool: VulnerabilityTool) -> bool:
        """Check if a vulnerability scanning tool is installed"""
        try:
            if tool == VulnerabilityTool.DALFOX:
                result = subprocess.run(["dalfox", "version"], capture_output=True, text=True, timeout=10)
                return result.returncode == 0
            
            elif tool == VulnerabilityTool.XSSTRIKE:
                # XSStrike is a Python tool, check if it exists in expected location
                xsstrike_path = "/opt/tools/XSStrike/xsstrike.py"
                return os.path.exists(xsstrike_path)
            
            elif tool == VulnerabilityTool.SQLMAP:
                result = subprocess.run(["sqlmap", "--version"], capture_output=True, text=True, timeout=10)
                return result.returncode == 0
            
            elif tool == VulnerabilityTool.CRLFUZZ:
                result = subprocess.run(["crlfuzz", "-h"], capture_output=True, text=True, timeout=10)
                return result.returncode == 0
            
            elif tool == VulnerabilityTool.QSREPLACE:
                result = subprocess.run(["qsreplace", "-h"], capture_output=True, text=True, timeout=10)
                return result.returncode == 0
            
            elif tool == VulnerabilityTool.NUCLEI:
                result = subprocess.run(["nuclei", "-version"], capture_output=True, text=True, timeout=10)
                return result.returncode == 0
            
            elif tool == VulnerabilityTool.NUCLEI_TEMPLATES:
                # Check if nuclei templates directory exists
                templates_path = "/opt/tools/nuclei-templates"
                return os.path.exists(templates_path) and os.listdir(templates_path)
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking {tool} installation: {str(e)}")
            return False
    
    async def install_tool(self, tool: VulnerabilityTool) -> Tuple[bool, str]:
        """Install a vulnerability scanning tool"""
        try:
            if tool == VulnerabilityTool.DALFOX:
                # Install dalfox using go install
                result = subprocess.run([
                    "go", "install", "github.com/hahwul/dalfox/v2@latest"
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    return True, "dalfox installed successfully"
                else:
                    return False, f"Failed to install dalfox: {result.stderr}"
            
            elif tool == VulnerabilityTool.XSSTRIKE:
                # Clone and setup XSStrike
                tools_dir = "/opt/tools"
                os.makedirs(tools_dir, exist_ok=True)
                
                result = subprocess.run([
                    "git", "clone", "https://github.com/s0md3v/XSStrike.git", 
                    f"{tools_dir}/XSStrike"
                ], capture_output=True, text=True, timeout=120)
                
                if result.returncode == 0:
                    # Install requirements
                    req_result = subprocess.run([
                        "pip", "install", "-r", f"{tools_dir}/XSStrike/requirements.txt"
                    ], capture_output=True, text=True, timeout=180)
                    
                    if req_result.returncode == 0:
                        return True, "XSStrike installed successfully"
                    else:
                        return False, f"Failed to install XSStrike requirements: {req_result.stderr}"
                else:
                    return False, f"Failed to clone XSStrike: {result.stderr}"
            
            elif tool == VulnerabilityTool.SQLMAP:
                # Install sqlmap using apt
                result = subprocess.run([
                    "apt", "update", "&&", "apt", "install", "-y", "sqlmap"
                ], capture_output=True, text=True, timeout=300, shell=True)
                
                if result.returncode == 0:
                    return True, "sqlmap installed successfully"
                else:
                    return False, f"Failed to install sqlmap: {result.stderr}"
            
            elif tool == VulnerabilityTool.CRLFUZZ:
                # Install crlfuzz using go install
                result = subprocess.run([
                    "go", "install", "github.com/dwisiswant0/crlfuzz/cmd/crlfuzz@latest"
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    return True, "crlfuzz installed successfully"
                else:
                    return False, f"Failed to install crlfuzz: {result.stderr}"
            
            elif tool == VulnerabilityTool.QSREPLACE:
                # Install qsreplace using go install
                result = subprocess.run([
                    "go", "install", "github.com/tomnomnom/qsreplace@latest"
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    return True, "qsreplace installed successfully"
                else:
                    return False, f"Failed to install qsreplace: {result.stderr}"
            
            elif tool == VulnerabilityTool.NUCLEI:
                # Install nuclei using go install
                result = subprocess.run([
                    "go", "install", "-v", "github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest"
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    return True, "nuclei installed successfully"
                else:
                    return False, f"Failed to install nuclei: {result.stderr}"
            
            elif tool == VulnerabilityTool.NUCLEI_TEMPLATES:
                # Clone nuclei templates
                templates_dir = "/opt/tools"
                os.makedirs(templates_dir, exist_ok=True)
                
                result = subprocess.run([
                    "git", "clone", "https://github.com/projectdiscovery/nuclei-templates.git",
                    f"{templates_dir}/nuclei-templates"
                ], capture_output=True, text=True, timeout=180)
                
                if result.returncode == 0:
                    return True, "nuclei-templates installed successfully"
                else:
                    return False, f"Failed to install nuclei-templates: {result.stderr}"
            
            return False, f"Unknown tool: {tool}"
            
        except Exception as e:
            logger.error(f"Error installing {tool}: {str(e)}")
            return False, f"Installation error: {str(e)}"
    
    async def scan_url_with_dalfox(self, url: str, timeout: int = 300) -> List[VulnerabilityInfo]:
        """Scan URL for XSS vulnerabilities using dalfox"""
        vulnerabilities = []
        
        try:
            # Run dalfox with JSON output
            cmd = [
                "dalfox", "url", url,
                "--format", "json",
                "--silence",
                "--timeout", str(timeout),
                "--worker", "10"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout + 60)
            
            if result.returncode == 0 and result.stdout.strip():
                try:
                    # Parse JSON output
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.strip():
                            data = json.loads(line)
                            
                            vuln = VulnerabilityInfo(
                                url=url,
                                parameter=data.get('param', ''),
                                payload=data.get('payload', ''),
                                method=data.get('method', 'GET'),
                                vulnerability_type=VulnerabilityType.XSS,
                                severity=self._map_dalfox_severity(data.get('severity', 'medium')),
                                confidence_score=float(data.get('confidence', 0.7)),
                                description=f"XSS vulnerability found in parameter '{data.get('param', 'unknown')}'",
                                evidence=data.get('evidence', ''),
                                remediation="Sanitize user input and use proper output encoding",
                                tool_used=VulnerabilityTool.DALFOX,
                                request_data={"payload": data.get('payload', '')},
                                response_data={"evidence": data.get('evidence', '')}
                            )
                            
                            vulnerabilities.append(vuln)
                            
                except json.JSONDecodeError as e:
                    logger.warning(f"Failed to parse dalfox JSON output: {str(e)}")
            
        except subprocess.TimeoutExpired:
            logger.warning(f"dalfox scan timed out for URL: {url}")
        except Exception as e:
            logger.error(f"Error running dalfox on {url}: {str(e)}")
        
        return vulnerabilities
    
    async def scan_url_with_xsstrike(self, url: str, timeout: int = 300) -> List[VulnerabilityInfo]:
        """Scan URL for XSS vulnerabilities using XSStrike"""
        vulnerabilities = []
        
        try:
            xsstrike_path = "/opt/tools/XSStrike/xsstrike.py"
            if not os.path.exists(xsstrike_path):
                logger.warning("XSStrike not found, skipping scan")
                return vulnerabilities
            
            cmd = [
                "python3", xsstrike_path,
                "-u", url,
                "--blind",
                "--crawl"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
            
            if result.returncode == 0:
                # Parse XSStrike output (text-based)
                output_lines = result.stdout.split('\n')
                
                for line in output_lines:
                    if "XSS" in line and "vulnerable" in line.lower():
                        # Extract basic vulnerability info from output line
                        vuln = VulnerabilityInfo(
                            url=url,
                            vulnerability_type=VulnerabilityType.XSS,
                            severity=VulnerabilitySeverity.MEDIUM,
                            confidence_score=0.8,
                            description="XSS vulnerability detected by XSStrike",
                            evidence=line.strip(),
                            remediation="Sanitize user input and use proper output encoding",
                            tool_used=VulnerabilityTool.XSSTRIKE
                        )
                        
                        vulnerabilities.append(vuln)
            
        except subprocess.TimeoutExpired:
            logger.warning(f"XSStrike scan timed out for URL: {url}")
        except Exception as e:
            logger.error(f"Error running XSStrike on {url}: {str(e)}")
        
        return vulnerabilities
    
    async def scan_url_with_sqlmap(self, url: str, timeout: int = 300) -> List[VulnerabilityInfo]:
        """Scan URL for SQL injection vulnerabilities using sqlmap"""
        vulnerabilities = []
        
        try:
            cmd = [
                "sqlmap", "-u", url,
                "--batch",
                "--random-agent",
                "--timeout", str(timeout // 2),
                "--retries", "1",
                "--level", "1",
                "--risk", "1"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
            
            if "vulnerable" in result.stdout.lower():
                # Parse sqlmap output for vulnerabilities
                vuln = VulnerabilityInfo(
                    url=url,
                    vulnerability_type=VulnerabilityType.SQLI,
                    severity=VulnerabilitySeverity.HIGH,
                    confidence_score=0.9,
                    description="SQL injection vulnerability detected by sqlmap",
                    evidence="SQLi detection confirmed",
                    remediation="Use parameterized queries and input validation",
                    tool_used=VulnerabilityTool.SQLMAP
                )
                
                vulnerabilities.append(vuln)
            
        except subprocess.TimeoutExpired:
            logger.warning(f"sqlmap scan timed out for URL: {url}")
        except Exception as e:
            logger.error(f"Error running sqlmap on {url}: {str(e)}")
        
        return vulnerabilities
    
    async def scan_url_with_crlfuzz(self, url: str, timeout: int = 300) -> List[VulnerabilityInfo]:
        """Scan URL for CRLF injection vulnerabilities using crlfuzz"""
        vulnerabilities = []
        
        try:
            cmd = ["crlfuzz", "-u", url, "-s"]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
            
            if result.returncode == 0 and result.stdout.strip():
                # Parse crlfuzz output
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if "CRLF" in line and url in line:
                        vuln = VulnerabilityInfo(
                            url=url,
                            vulnerability_type=VulnerabilityType.CRLF,
                            severity=VulnerabilitySeverity.MEDIUM,
                            confidence_score=0.8,
                            description="CRLF injection vulnerability detected",
                            evidence=line.strip(),
                            remediation="Sanitize user input and validate headers",
                            tool_used=VulnerabilityTool.CRLFUZZ
                        )
                        
                        vulnerabilities.append(vuln)
            
        except subprocess.TimeoutExpired:
            logger.warning(f"crlfuzz scan timed out for URL: {url}")
        except Exception as e:
            logger.error(f"Error running crlfuzz on {url}: {str(e)}")
        
        return vulnerabilities
    
    async def scan_url_with_nuclei(self, url: str, timeout: int = 300) -> List[VulnerabilityInfo]:
        """Scan URL using nuclei with templates"""
        vulnerabilities = []
        
        try:
            templates_path = "/opt/tools/nuclei-templates"
            if not os.path.exists(templates_path):
                logger.warning("nuclei-templates not found, skipping nuclei scan")
                return vulnerabilities
            
            cmd = [
                "nuclei", "-u", url,
                "-t", templates_path,
                "-json",
                "-silent",
                "-timeout", str(timeout // 2)
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
            
            if result.returncode == 0 and result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if line.strip():
                        try:
                            data = json.loads(line)
                            
                            vuln = VulnerabilityInfo(
                                url=url,
                                vulnerability_type=self._map_nuclei_type(data.get('template-id', '')),
                                severity=self._map_nuclei_severity(data.get('info', {}).get('severity', 'medium')),
                                confidence_score=0.8,
                                description=data.get('info', {}).get('name', 'Vulnerability detected by nuclei'),
                                evidence=data.get('matched-at', ''),
                                remediation=data.get('info', {}).get('remediation', 'Follow security best practices'),
                                tool_used=VulnerabilityTool.NUCLEI,
                                request_data={"template": data.get('template-id', '')},
                                response_data=data.get('response', {})
                            )
                            
                            vulnerabilities.append(vuln)
                            
                        except json.JSONDecodeError:
                            continue
            
        except subprocess.TimeoutExpired:
            logger.warning(f"nuclei scan timed out for URL: {url}")
        except Exception as e:
            logger.error(f"Error running nuclei on {url}: {str(e)}")
        
        return vulnerabilities
    
    async def scan_vulnerabilities(
        self, 
        urls: List[str], 
        target_id: str, 
        domain: str, 
        tools: List[VulnerabilityTool],
        deep_scan: bool = False,
        max_threads: int = 10,
        timeout_per_url: int = 300
    ):
        """Perform vulnerability scanning on multiple URLs"""
        db = get_database()
        
        # Find the job
        job = await db.vulnerability_jobs.find_one({"target_id": target_id, "status": "pending"})
        if not job:
            logger.error(f"No pending vulnerability scan job found for target {target_id}")
            return
        
        job_id = job["id"]
        
        try:
            # Update job status to running
            await db.vulnerability_jobs.update_one(
                {"id": job_id},
                {
                    "$set": {
                        "status": "running",
                        "started_at": datetime.utcnow()
                    }
                }
            )
            
            results = []
            total_vulnerabilities = 0
            severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
            
            # Process URLs with limited concurrency
            semaphore = asyncio.Semaphore(max_threads)
            
            async def scan_single_url(url: str) -> VulnerabilityScanResult:
                async with semaphore:
                    return await self._scan_single_url_with_tools(url, tools, timeout_per_url)
            
            # Run scans concurrently
            scan_tasks = [scan_single_url(url) for url in urls]
            results = await asyncio.gather(*scan_tasks, return_exceptions=True)
            
            # Process results
            valid_results = []
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    logger.error(f"Error scanning URL {urls[i]}: {str(result)}")
                    # Create failed result
                    failed_result = VulnerabilityScanResult(
                        url=urls[i],
                        subdomain=urls[i].split("//")[1].split("/")[0] if "//" in urls[i] else urls[i],
                        scan_status="failed",
                        error_message=str(result)
                    )
                    valid_results.append(failed_result)
                else:
                    valid_results.append(result)
                    total_vulnerabilities += result.total_vulnerabilities
                    severity_counts["critical"] += result.critical_count
                    severity_counts["high"] += result.high_count
                    severity_counts["medium"] += result.medium_count
                    severity_counts["low"] += result.low_count
                    severity_counts["info"] += result.info_count
            
            # Update job with results
            completed_urls = len([r for r in valid_results if r.scan_status == "completed"])
            failed_urls = len([r for r in valid_results if r.scan_status == "failed"])
            
            await db.vulnerability_jobs.update_one(
                {"id": job_id},
                {
                    "$set": {
                        "status": "completed" if failed_urls == 0 else "partial",
                        "completed_at": datetime.utcnow(),
                        "results": [result.dict() for result in valid_results],
                        "completed_urls": completed_urls,
                        "failed_urls": failed_urls,
                        "total_vulnerabilities": total_vulnerabilities,
                        "critical_vulnerabilities": severity_counts["critical"],
                        "high_vulnerabilities": severity_counts["high"],
                        "medium_vulnerabilities": severity_counts["medium"],
                        "low_vulnerabilities": severity_counts["low"],
                        "info_vulnerabilities": severity_counts["info"]
                    }
                }
            )
            
            # Update target vulnerability counts
            await db.targets.update_one(
                {"id": target_id},
                {
                    "$inc": {
                        "vulnerabilities": total_vulnerabilities,
                        "critical_vulnerabilities": severity_counts["critical"],
                        "high_vulnerabilities": severity_counts["high"]
                    },
                    "$set": {
                        "last_vulnerability_scan": datetime.utcnow()
                    }
                }
            )
            
            logger.info(f"Vulnerability scan completed for target {target_id}. Found {total_vulnerabilities} vulnerabilities.")
            
        except Exception as e:
            logger.error(f"Error in vulnerability scanning job {job_id}: {str(e)}")
            
            # Update job status to failed
            await db.vulnerability_jobs.update_one(
                {"id": job_id},
                {
                    "$set": {
                        "status": "failed",
                        "completed_at": datetime.utcnow(),
                        "error_message": str(e)
                    }
                }
            )
    
    async def _scan_single_url_with_tools(self, url: str, tools: List[VulnerabilityTool], timeout: int) -> VulnerabilityScanResult:
        """Scan a single URL with specified tools"""
        start_time = datetime.utcnow()
        all_vulnerabilities = []
        subdomain = url.split("//")[1].split("/")[0] if "//" in url else url.split("/")[0]
        
        try:
            # Run each tool on the URL
            for tool in tools:
                try:
                    if tool == VulnerabilityTool.DALFOX:
                        vulns = await self.scan_url_with_dalfox(url, timeout)
                        all_vulnerabilities.extend(vulns)
                    
                    elif tool == VulnerabilityTool.XSSTRIKE:
                        vulns = await self.scan_url_with_xsstrike(url, timeout)
                        all_vulnerabilities.extend(vulns)
                    
                    elif tool == VulnerabilityTool.SQLMAP:
                        vulns = await self.scan_url_with_sqlmap(url, timeout)
                        all_vulnerabilities.extend(vulns)
                    
                    elif tool == VulnerabilityTool.CRLFUZZ:
                        vulns = await self.scan_url_with_crlfuzz(url, timeout)
                        all_vulnerabilities.extend(vulns)
                    
                    elif tool == VulnerabilityTool.NUCLEI:
                        vulns = await self.scan_url_with_nuclei(url, timeout)
                        all_vulnerabilities.extend(vulns)
                    
                    # Note: qsreplace is a utility tool, not a scanner itself
                    
                except Exception as e:
                    logger.error(f"Error running {tool} on {url}: {str(e)}")
                    continue
            
            # Calculate severity counts
            severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
            for vuln in all_vulnerabilities:
                severity_counts[vuln.severity.value] += 1
            
            scan_duration = (datetime.utcnow() - start_time).total_seconds()
            
            result = VulnerabilityScanResult(
                url=url,
                subdomain=subdomain,
                scan_status="completed",
                vulnerabilities=all_vulnerabilities,
                total_vulnerabilities=len(all_vulnerabilities),
                critical_count=severity_counts["critical"],
                high_count=severity_counts["high"],
                medium_count=severity_counts["medium"],
                low_count=severity_counts["low"],
                info_count=severity_counts["info"],
                tools_used=tools,
                scan_duration=scan_duration,
                scanned_at=datetime.utcnow()
            )
            
            return result
            
        except Exception as e:
            logger.error(f"Error scanning URL {url}: {str(e)}")
            return VulnerabilityScanResult(
                url=url,
                subdomain=subdomain,
                scan_status="failed",
                error_message=str(e)
            )
    
    def _map_dalfox_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map dalfox severity to our enum"""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.INFO
        }
        return severity_map.get(severity.lower(), VulnerabilitySeverity.MEDIUM)
    
    def _map_nuclei_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map nuclei severity to our enum"""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.INFO
        }
        return severity_map.get(severity.lower(), VulnerabilitySeverity.MEDIUM)
    
    def _map_nuclei_type(self, template_id: str) -> VulnerabilityType:
        """Map nuclei template ID to vulnerability type"""
        if "xss" in template_id.lower():
            return VulnerabilityType.XSS
        elif "sqli" in template_id.lower() or "sql" in template_id.lower():
            return VulnerabilityType.SQLI
        elif "rce" in template_id.lower():
            return VulnerabilityType.REMOTE_CODE_EXECUTION
        elif "lfi" in template_id.lower():
            return VulnerabilityType.LOCAL_FILE_INCLUSION
        elif "rfi" in template_id.lower():
            return VulnerabilityType.REMOTE_FILE_INCLUSION
        elif "auth" in template_id.lower():
            return VulnerabilityType.AUTHENTICATION
        elif "cors" in template_id.lower():
            return VulnerabilityType.CORS_MISCONFIGURATION
        elif "redirect" in template_id.lower():
            return VulnerabilityType.OPEN_REDIRECT
        else:
            return VulnerabilityType.OTHER


# Global service instance
vulnerability_service = VulnerabilityService()